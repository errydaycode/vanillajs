//Promise – это объект.
// Этот объект нам как правило возвращает какая-то функция вместо конкретного результата, которого мы от неё (функции) хотим.
// То есть функция могла бы вернуть нам конкретные данные, которые мы от неё просим, но она возвращает обещание (Promise) эти данные вернуть, но чуть-чуть попозже.
// Так происходит, потому что у логики, которая зашита внутри функции, нет этих данных здесь и сейчас.
// То есть она не может прямо сейчас их отдать, потому что за ними нужно полезть с запросом на сервер, либо в базу данных, либо читать с файла,
// а это длительные операции и её выполнять долго нужно. И чтобы единственный поток и приложение не зависло, это нужно обязательно делать асинхронно,
// а когда эта асинхронная логика закончится, нужно попасть в эту логику и забрать эти данные. И чтобы это было проще делать, функция говорит – я тебе верну промис.
// Например, мы просим функцию сделать запрос на сервер за какими-то данными, и она бы нам их могла вернуть, если бы запрос на сервер проходил мгновенно.
// Но так как запрос на сервер не происходит мгновенно, функция возвращает нам промис (обещание вернуть эти данные, но чуть позже).
// Или например мы просим найти пользователя в базе данных, функция сразу же вернет промис, и побежит искать этого юзера,
// но чтобы наш синхронный код не остановился, мы получим промис, код пойдет выполняться дальше, и когда наш пользователь найдется,
// мы сможем его получить из нашего объекта промис, который вернула нам функция. С помощью метода then мы даем инструкцию, что делать после того как обещание выполнено.
// То есть мы говорим, выполни эту функцию, когда ты промис выполнишься( зарезолвишсья).
// Как только промис родился, он находится в состоянии pending (ожидание) – дал обещание и пошёл делать дела.
// Может быть обещание выполнится, но пока оно не выполнено – pending.
// Когда промис выполнен, он переходит в состояние fulfilled(так же можно назвать зарезолвился, значит выполнился) .
// Это тоже некое событие. И чтобы нам узнать об этом событии, то есть подписаться на его выполнение, мы используем метод then.
// Стандартный паттер слушателя – издатель/подписчик. Издатель – промис.
// Он может сказать что он зарезолвился, с помощью метода then мы на это событие подписываемся, передавая ему коллБэк функцию.
// Подписаться значит выполнить коллбек функцию тогда, когда промис зарезолвится (когда обещание выполнится).
// И в этот коллбек как правило приходят те данные, которые нам обещали достать, и тут уже мы можем с ними работать.
// Промис нам возвращается для того, чтобы программа могла идти дальше. Мы подписываемся на тот момент, когда наша функция зарезолвится.
// То есть нам вернули обещание, код пошел дальше, но мы подписались методом then, и сказали что когда обещание выполнится, выполни эту коллБек фукнцию, которую мы передали в then.
// И в эту функцию промис засунул те данные, которые он обещал засунуть. Подписаться значит выполнить коллбек функцию тогда, когда промис зарезолвится (когда обещание выполнится).
// Функция делает асинхронный запрос в б/д. Но нам, пока он делается, вернула промис.
// Поэтому мы пишем логику на тот случай, когда промис выполнится и вернет нам данные из б/д.
// Мы пишем – promise.then((user)=> {console.log(user)}), и говорим эй промис, затем(когда) ты зарезолвишься, выполни эту коллБек функцию, и в неё засунь этого юзера,
// которого мы там у тебя запросили. И мы этого юзера выведем в консоль.
//
// Микроитог- промис это объект. У него есть самый главный метод – then, с помощью которого мы можем подписаться на момент,
// когда promise зарезолвится и наша функция-подписчик, которую мы передали как коллБэк в метод then, вызывается, и в эту функцию передаются данные,
// которыми зарезолвился промис. Как правило, промис обещает вернуть нам какие-то данные.