// 1111.ts, then, catch, finally
// Зачем нужны промисы ? Даже запрос на сервер занимает время
// это действия, которые блокиурют поток кода
// если мы будем синхронно выполнять запрос на сервер синхронно, то на время этого запроса код остановится на этом месте
// и код зависнет на одном месте. Ничего нельзя будет сделать пока код с запросом не выполнится.

import { log } from "console"

// const fetch = (url, callback) => {
//     // где-то тут выполняет запрос на сервер и дожидается ответа --> url
//
//     callback(err ,data) //и в этот колл бек передает дату
// }
//
// // Есть книжный магазин, в котором есть книги и список авторов, мы хотим выбрать книгу:
//
// fetch('https://bookssite.com/authors',(err, data) =>{
//     if(err) {
//         console.log('something went wrong')
//     } else {
//         fetch('https://bookssite.com/authors/id45',(err, data) =>{
//             if(err) {
//                 console.log('something went wrong')
//             } else {
//
//             }
//     }
// } )

//В чем смысл промисов - когда мы хотим сделать какое-то асинхронное действие, мы в коде должны работать
// с какой-то сущностью и для асинхронных действий есть специальная сущность, которая возвращает нам обещаение(Промис)
// . В чем его суть - мы делаем запрос на сервер. Чтобы код мог идти дальше, не останавливаясь дожидаясь ответа от сервера,
// нам возвращается объект промиса, и мы дальше идем по коду.
//
// Промис - это объект. Когда мы делаем какое-то асинхронное действие, он нам возвращается. Объект имеет два основых поля - статус и резалт.
// Пока статус pending - в result сидит undefined.
// что помещается в result? то, что мы передадим в наши функции resolve или rejectd при их вызове
// JS наблюдает за состоянием промиса, но когда мы получили объект промиса, наш код не останавливается - он продолжает работать,
// но следит за его состоянием, когда его состояние меняется - JS может с ним продолжать работать
// состояние может изменится с pending на два состояния - промис резолвится ( fulfilled)
// либо зареджектится - rejected
// если промис перешел из pending в fullfiled или rejected - назад в пендинг он перейти не может
// как и перейти из фуллфиллед в реджектед или наоборот . Изменение состояния работает только раз

// конструктор промиса всегда принимает в себя коллБек функцию (executor), а уже в неё параметром приходят 2-фии :
// res и rej, это как раз ф-ии, которые переводят наш промис в фуллфиллед или режектед



const promise = new Promise((resolve, reject)=> {
    const data = {
        id: '8934rc',
        name: 'John'
    }
    // const data = null

    setTimeout(()=> {
        if (data) {
            resolve(data)
        }
        else {
            reject('some error')
        }
    }, 1000)
})

// promise.then((data)=> {
//     console.log(data)
// }).catch((err)=> {
//     console.log(err)
// }).finally(()=> {
//     console.log('finally')
// })

promise
    .then((data)=> {
        console.log('then 1', data)
        return 10
    })
    .then((data)=> {
        console.log('then2 ' , data)
        return undefined
    })
    .catch((err)=> {
        console.log('Catch1 ' , err)
        return 40
    })
    .then((data)=> {
        console.log('then3', data)
        return 60
    })
    .catch((err)=> {
        console.log('Catch2 ' , err)
        return 30
    })
    .finally(()=> {
        console.log('finally')
        return 70
    })
    .then((data)=> {
        console.log('then4', data)

    })